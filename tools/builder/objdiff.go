package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// https://raw.githubusercontent.com/encounter/objdiff/refs/heads/main/config.schema.json

type objdiffMetadata struct {
	Complete           bool     `json:"complete"`
	ReverseFnOrder     bool     `json:"reverse_fn_order"`
	SourcePath         string   `json:"source_path,omitempty"`
	ProgressCategories []string `json:"progress_categories,omitempty"`
	AutoGenerated      bool     `json:"auto_generated"`
}

type objdiffUnit struct {
	Name           string          `json:"name,omitempty"`
	Path           string          `json:"path,omitempty"`
	TargetPath     string          `json:"target_path,omitempty"`
	BasePath       string          `json:"base_path,omitempty"`
	ReverseFnOrder bool            `json:"reverse_fn_order"`
	Complete       bool            `json:"complete"`
	Metadata       objdiffMetadata `json:"metadata"`
}

type objdiffProgressCategory struct {
	ID   string `json:"id"`
	Name string `json:"name,omitempty"`
}

type objdiffConfig struct {
	CustomMake       string                    `json:"custom_make,omitempty"`
	BaseDir          string                    `json:"base_dir,omitempty"`
	BuildBase        bool                      `json:"build_base"`
	TargetDir        string                    `json:"target_dir,omitempty"`
	BuildTarget      bool                      `json:"build_target"`
	WatchPatterns    []string                  `json:"watch_patterns,omitempty"`
	IgnorePatterns   []string                  `json:"ignore_patterns,omitempty"`
	Units            []objdiffUnit             `json:"units,omitempty"`
	ProgressCategory []objdiffProgressCategory `json:"progress_categories,omitempty"`
}

func makeObjdiffConfig(b BuildConfig) objdiffConfig {
	var units []objdiffUnit
	var categories []objdiffProgressCategory
	for _, o := range b.Overlays {
		srcDir := filepath.Join(b.SrcPath, o.BasePath)
		for _, src := range o.Segments {
			if len(src) < 2 {
				continue
			}
			if cat, ok := src[1].(string); !ok || cat != "c" {
				continue
			}
			name := ""
			if len(src) >= 3 {
				if n, ok := src[2].(string); ok {
					name = n
				}
			}
			if name == "" {
				if v, ok := src[0].(uint64); ok {
					name = strconv.FormatInt(int64(v), 16)
					name = strings.ToUpper(name)
				}
			}
			if name == "" {
				panic("bug")
			}
			category := fmt.Sprintf("%s/%s", o.Name, name)
			categories = append(categories, objdiffProgressCategory{
				ID: category,
			})
			srcFile := filepath.Join(srcDir, name+".c")
			objFile := filepath.Join(b.BuildPath, srcFile+".o")
			units = append(units, objdiffUnit{
				Name:       o.Name,
				BasePath:   objFile,
				TargetPath: targetPath(objFile),
				Metadata: objdiffMetadata{
					SourcePath:         srcFile,
					ProgressCategories: []string{category},
				},
			})
		}
	}
	return objdiffConfig{
		CustomMake:  "ninja",
		BaseDir:     b.BuildPath,
		BuildBase:   true,
		TargetDir:   targetPath(b.BuildPath),
		BuildTarget: false,
		WatchPatterns: []string{
			"include/**.h",
			"src/**.c",
			"src/**.h",
		},
		IgnorePatterns: []string{
			"build/**/*",
		},
		Units:            units,
		ProgressCategory: categories,
	}
}

func writeObjdiffConfig(b BuildConfig) error {
	data, err := json.Marshal(makeObjdiffConfig(b))
	if err != nil {
		return err
	}
	return os.WriteFile("objdiff.json", data, 0644)
}

func targetPath(path string) string {
	path = strings.Replace(path, "report/", "", 1)
	return filepath.Join("expected", path)
}
