## FF7 Decomp: Working Notes for Agents

Final Fantasy VII (PS1 USA) decompilation project. Goal: byte-accurate recompilation of game executables.

## Quick Reference

### Docker Build Commands (Optimized)
```shell
# Build Docker image (only needed once)
docker build --platform=linux/amd64 --tag ff7-build:latest .

# Run a build (FAST - uses Go caching, ~12s clean, ~2s incremental)
./tools/docker-build.sh "make build"

# Format code after changes
./tools/docker-build.sh "make format"

# Enter container interactively
./tools/docker-build.sh bash
```

The `docker-build.sh` wrapper adds Go module and build caching which provides a significant speedup.

**Legacy commands** - only use if you have issues with the optimized script:
```shell
docker run --rm --platform=linux/amd64 -v "$(pwd)":/ff7 -v ff7_venv:/ff7/.venv -v "$(pwd)/build":/ff7/build ff7-build:latest -lc 'cd /ff7 && make build'
```

### Key Make Targets
- `make build` - Build all overlays, verify SHA1 checksums
- `make format` - Run clang-format on code
- `make clean` - Remove build artifacts
- `make submit` - Clean + build + format + stage files for commit

### Mako Commands (via `./mako.sh`)
- `./mako.sh build` - Build project
- `./mako.sh dec <func_name>` - Decompile function, replace INCLUDE_ASM
- `./mako.sh dec <func_name> --fix-structs` - Also replace D_8009XXXX with Savemap fields
- `./mako.sh rank <asm_dir>` - Rank functions by difficulty (easiest first)
- `./mako.sh symbols add <path> <name> <offset> [size]` - Add new symbol
- `./mako.sh format` - Format code

## Project Structure

```
src/                    # Decompiled C source (organized by overlay)
asm/us/                 # MIPS assembly (original/undecompiled)
  └── <overlay>/
      ├── nonmatchings/ # Undecompiled function .s files
      └── data/         # Data segment .s files
include/                # Headers (common.h, game.h, psxsdk/)
config/                 # Build config and symbol files
  ├── us.yaml          # Main overlay definitions
  ├── symbols.*.txt    # Symbol address files
  └── sym_*.txt        # Import/export symbol files
build/us/              # Build output (.o, .exe, .map files)
tools/                 # Build tools (Go builder, Python scripts)
disks/us/              # Extracted game files (from disc image)
```

## Overlays

| Overlay | VRAM Start | Source | Description |
|---------|------------|--------|-------------|
| main | 0x80010000 | `src/main/` | Core engine, initialization |
| battle | 0x800A0000 | `src/battle/` | Battle system |
| batini | 0x801B0000 | `src/battle/batini.c` | Battle initialization |
| field | 0x800A0000 | `src/field/` | Field exploration |
| world | 0x800A0000 | `src/world/` | World map |
| menu | varies | `src/menu/` | Menu systems (savemenu, title, etc.) |

## Decompilation Workflow

### 1. Find a function to decompile
```shell
# List undecompiled functions, ranked by difficulty (easiest first)
./mako.sh rank src/battle/nonmatchings/battle

# Or browse asm files directly
ls asm/us/battle/nonmatchings/battle/
```

### 2. Decompile with m2c
```shell
# This replaces INCLUDE_ASM in the .c file with decompiled code and performs struct field replacement
./mako.sh dec func_800A1158 --fix-structs
```

### 3. Refine the code
- Fix unknown types (marked with `/*?*/`)
- Match register allocation and instruction order
- Add/reference symbols in `config/symbols.*.txt`
- The goal is to produce a decompiled code that is 1:1 matching the original PSX binaries

### 4. Build and verify
```shell
make build  # Rebuilds and verifies SHA1 match
```

### 5. Format and submit
```shell
make format
git add config/ include/ src/
git commit -m "Decompile func_800A1158"
```

## Code Patterns

### INCLUDE_ASM Macro
Embeds undecompiled assembly:
```c
INCLUDE_ASM("asm/us/battle/nonmatchings/battle", func_800A1158);
```
Replace with decompiled C code when function matches.

### Renaming INCLUDE_ASM Functions

INCLUDE_ASM functions can be renamed without decompiling them. The process differs between the **main overlay** and **other overlays**:

#### Main Overlay (src/main/*.c)
The asm files in `asm/us/main/nonmatchings/` are **static** - they persist on disk and are not regenerated.

To rename a function (e.g., `func_80026F44` → `MenuDrawText`):
1. **Rename the asm file**: `mv asm/us/main/nonmatchings/18B8/func_80026F44.s asm/us/main/nonmatchings/18B8/MenuDrawText.s`
2. **Update the asm file contents**:
   - Change `glabel func_80026F44` → `glabel MenuDrawText`
   - Change `.size func_80026F44, . - func_80026F44` → `.size MenuDrawText, . - MenuDrawText`
3. **Update the INCLUDE_ASM macro** in the C file
4. **Update all call sites** in `src/` that reference this function
5. **Update the symbol file** (e.g., `config/symbols.main.us.txt`)

#### Other Overlays (src/menu/*.c, src/battle/*.c, etc.)
The asm files in overlay directories are **regenerated by splat** on each build. Renaming the files directly won't work - splat will recreate them with the old names.

To rename a function (e.g., `func_801D080C` → `MenuConfig` in cnfgmenu):
1. **Add the new name to the overlay's symbol file** (e.g., `config/symbols.cnfgmenu.us.txt`):
   ```
   MenuConfig = 0x801D080C;
   ```
2. **Update `config/sym_ovl_export.us.txt`** (for cross-overlay references):
   - Change `func_801D080C = 0x801d080c;` → `MenuConfig = 0x801d080c;`
3. **Update the INCLUDE_ASM macro** in the C file
4. **Update any references** in other files (e.g., `src/main/ovl.c` for exported functions)
5. **Run the build** - splat will generate the asm file with the new name

The old asm file may remain in the directory but will be unused. It can be deleted manually.

### Common Types
```c
typedef signed char s8;      typedef unsigned char u8;
typedef signed short s16;    typedef unsigned short u16;
typedef signed int s32;      typedef unsigned int u32;
typedef u8 unk_data;         typedef unsigned int* unk_ptr;
```

### String Encoding
FF7 uses custom character encoding, not ASCII. Use `_S()` macro:
```c
const char* msg = _S("Save game?");
```

## Naming Conventions

### Functions
- Undecompiled: `func_800XXXXX` (address-based)
- Decompiled: verb-first descriptive names, prefer PSX SDK names when applicable
- Examples: `InitBattle`, `LoadScene`, `DrawSprite`

### Data/Globals
- Unknown: `D_800XXXXX` (address-based)
- Known game state: `g_` prefix (e.g., `g_BattleState`)
- Module constants: module prefix (e.g., `BATTLE_MAX_ENEMIES`)
- Struct fields: `unkXX` until purpose known

## Symbol Files

Located in `config/`:
- `symbols.main.us.txt` - Main overlay symbols
- `symbols.battle.txt` - Battle overlay symbols
- `sym_export.us.txt` - Cross-overlay exports
- `sym_extern.us.txt` - External references

Format:
```
function_name = 0x800A1158;
D_800F5BB8 = 0x800F5BB8; // size:0xCC
```

Add symbols with:
```shell
./mako.sh symbols add config/symbols.battle.txt MyFunction 0x800A1234
```

## Key Data Structures

### Savemap (0x8009C6E4)
Game save data. Use `--fix-structs` to auto-replace `D_8009XXXX` references:
- `Savemap.party[9]` - Party member data
- `Savemap.inventory` - Item inventory
- `Savemap.materia` - Materia slots
- `Savemap.gil` - Money
- See `tools/fix_structs.py` for full field list

### Battle Structures (`src/battle/battle.h`)
- `BattleSetup` - Battle configuration
- `Unk800F83E0` - Battle state (0x68 bytes)
- `BattleSetupType` - Encounter types (preemptive, back attack, etc.)

## Tips for Matching

1. **Compiler quirks**: Two PSX compilers available (`cc1-psx-26`, `cc1-psx-272`). Check which one the overlay uses in `config/us.yaml`.

2. **Register allocation**: Order of operations matters. Sometimes restructuring expressions helps match.

3. **Global pointer (GP)**: Main overlay uses `gp=0x80062D44`. Variables near this use gp-relative addressing.

4. **Rodata association**: Battle overlay has `migrate_rodata_to_functions: true` - rodata is bundled with functions.

5. **Use mipsel-linux-gnu-objdump** for line-by-line comparison

## Comparing Original vs Compiled Assembly

When a decompiled function doesn't match, compare the original assembly with the compiled output:

### 1. Check Function Size (Quick Check)
```shell
# Get compiled function size from symbol table
./tools/docker-build.sh "mipsel-linux-gnu-objdump -t build/us/src/main/18B8.c.o" | grep func_80026F44

# Output: 00015e8c g F .text 00000128 func_80026F44
#         ^^^^^^^^         ^^^^^^^^ <- size in hex (0x128 = 296 bytes)
```

Compare with original size: count bytes from function start to end in the `.s` file, or calculate from addresses (end_addr - start_addr + 4).

### 2. View Compiled Disassembly
```shell
# Disassemble a specific function from the compiled object
./tools/docker-build.sh "mipsel-linux-gnu-objdump -d build/us/src/main/18B8.c.o" | grep -A100 '<func_80026F44>:'
```

### 3. View Original Assembly
```shell
# Original assembly is in asm/us/<overlay>/nonmatchings/<file>/
cat asm/us/main/nonmatchings/18B8/func_80026F44.s
```

### 4. Common Size Mismatch Causes
- **Code merged after branches**: Compiler optimizes common code after if/else. Fix: put function calls inside each branch.
- **Delay slot optimization**: Original uses delay slots cleverly. The compiled code may not reproduce this.
- **Sign extension duplication**: Original may have `sll/sra` pairs duplicated in branches; compiler merges them.
- **Register allocation**: Different register choices can cause different instruction sequences.
- **Type differences**: `s8` vs `u8` generates `lb` vs `lbu` instructions.

### 5. Useful Patterns
```shell
# Count instructions in original (each line with glabel excluded, /* */ comments have instructions)
grep -c '/\*' asm/us/main/nonmatchings/18B8/func_80026F44.s

# Find jr ra (function returns) to identify function boundaries
./tools/docker-build.sh "mipsel-linux-gnu-objdump -d build/us/src/main/18B8.c.o" | grep 'jr.*ra'
```

## Decompilation Tips Checklist 

When decompiling a function, follow this checklist:

- [ ] No prototypes or parameters with '?' as type
- [ ] No 'void*' parameters that should be typed structs 
- [ ] No pointer arithmetic with manual offset calculations 
- [ ] Use array indices to access arrays, do not use arithmetic calculations
- [ ] All struct field accesses use '->' or '.' operators
- [ ] Struct sizes match the assembly access patterns
- [ ] 'goto loop_*' are converted as 'while' loops 
- [ ] 'goto block_*' in 'switch' are inlined, to reverse code optimization 

Alignment is critical. Code and data are aligned by 4-byte.

## Finding symbol names and applying them to the decompiled code

Our goal in this project currently is to find out as many symbol names (functions, variables, enums, structs, local variables, function parameters) as possible and apply them to the decompiled code. At the same time we want to ensure the code compiles 1:1 matching the original PSX binaries so we cannot alter the parameter types and change any logic.

1. First we need to analyse both the decompiled PSX code in the @src/ folder and the PC decompiled code in the @assets/ folder. You usually start with a function in the PSX code that is unique enough and already has some symbols decompiled or its logic is recognizable enough that it can be matched to the PC code.
2. Spawn a sub-agent to look through the PC code in the @assets/ folder (do not read these files directly because they're huge) and find any corresponding code that can help us find new symbol names
3. Map out the connections between the PSX code (skip function names defined with INCLUDE_ASM macro, only functions fully defined in C can be renamed) and the PC code and store your findings in @CLAUDE_DECOMP.md for future reference. Make sure you're absolutely certain when creating this mapping - if there is any doubt about a specific symbol you should skip it.
4. Apply the changes. To do this spawn an Apply sub-agent that will take a map of symbol names to update (eg. "func_800A1158 = MyFunction", "D_800F5BB8 = MyVariable") and then the sub-agent will figure out how to efficiently and comprehensively apply these changes to the PSX code in @src/ (remember to update references to the changed symbol names in other source and header files; when changing a function name you should update all function calls to it in the code). The sub-agent should think hard to make sure it does not break anything as some symbol names are used in multiple places. The sub-agent shall not alter parameter types in function signatures. The sub-agent shall not read or update the assembly files in asm/ (these are generated by the disassembler and should not be manually edited). After finishing applying the changes it should return immediately without trying to run the build. 
5. In parallel spawn a second sub-agent that will update the symbol maps in @config/ in symbols.main.us.txt and any other *.txt files that contain symbol names (skip sym_export.us.txt and sym_export_battle.us.txt since these are autogenerated by the build system)
6. After the work is done run the build to verify if the changes are correct. The build should succeed without any errors and all the SHA1 sums should match. Fix any issues that arise and repeat the process until the changes are correct.
7. Take one more look at CLAUDE_DECOMP.md and make sure its updated with all the new knowledge you've gained.
8. Finally think about what the next steps would be and suggest options to the user

## Files to Commit
When submitting decompiled code:
```shell
git add config/    # Symbol files
git add include/   # Headers (if modified)
git add src/       # Decompiled source
```

## Advanced Matching Techniques

### Understanding Why Decompiled Code Doesn't Match

When the size is wrong, the compiler is generating different code structure. Common causes:

#### 1. Merged Function Calls
**Problem**: Modern compilers merge common code after if/else branches.
```c
// BAD - compiler merges the call after the branches
if (condition) {
    setup_a();
} else {
    setup_b();
}
common_call();  // Compiler optimizes: one call site

// GOOD - forces separate code paths (matches original)
if (condition) {
    setup_a();
    common_call();  // Call inside branch
} else {
    setup_b();
    common_call();  // Duplicate call
}
```

#### 2. Variable Type Affects Load Instructions
- `s8` generates `lb` (load byte signed)
- `u8` generates `lbu` (load byte unsigned)
- Check if global variables need type changes to match original instructions

#### 3. Struct vs Separate Variables
**Problem**: Compiler optimizes away stores to local variables if it thinks they're unused.
```c
// BAD - compiler may skip storing to sp1C, sp1E
s16 sp18, sp1A, sp1C, sp1E;
sp1C = 0xFF;  // May be optimized away!
sp1E = 0xFF;
sp18 = 0;
sp1A = 0;
SetDrawMode(..., (RECT*)&sp18);

// GOOD - using proper struct ensures all fields are stored
RECT rect;
rect.w = 0xFF;  // Compiler knows RECT fields are accessed
rect.h = 0xFF;
rect.x = 0;
rect.y = 0;
SetDrawMode(..., &rect);
```

#### 4. Delay Slot Optimization
Original PSX compiler often put useful instructions in branch delay slots. Modern compilers may:
- Put the instruction before the branch instead
- Use NOP in delay slots

Example: Original saves `y << 16` before loop, uses delay slot for `s2 = 0`:
```asm
beqz v0, check_mode
addu s2, zero, zero   # delay slot: s2 = 0
sll s1, a1, 16        # after branch: save y
```

#### 5. Redundant Instructions in Original
The original compiler sometimes generated redundant code:
- `andi t0, v1, 0xFF` after `lbu v1` (already 8-bit)
- Duplicate `sra a1, s1, 16` in both branches

These are hard to reproduce with modern compilers without tricks.

### Matching Workflow

1. **Get size right first** - Restructure code until instruction count matches (note: if the output size is wrong you might see compiler/linker errors in unrelated files - this is a good indicator that the size is wrong)
2. **Fix types second** - Change s8/u8, s16/u16 to match load/store instructions
3. **Reorder operations** - Match the order of stores/loads in original
4. **Check branch structure** - Use goto labels to match original control flow
5. Look at other decompiled functions in the same file to see how they handle similar patterns to the ones you're trying to match

### Debugging Commands
```shell
# Compare function sizes
./tools/docker-build.sh "mipsel-linux-gnu-objdump -t build/us/src/main/18B8.c.o" | grep func_NAME

# View compiled assembly
./tools/docker-build.sh "mipsel-linux-gnu-objdump -d build/us/src/main/18B8.c.o" | grep -A100 '<func_NAME>:'

# Original is in asm/us/<overlay>/nonmatchings/<file>/func_NAME.s
```

## Reference Links
- PSX SDK docs: PSY-Q library documentation
- FF7 Scarlet: https://github.com/petfriendamy/ff7-scarlet (game data structures)
